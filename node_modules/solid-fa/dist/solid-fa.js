var SolidFa = (function (exports) {
  'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var sharedConfig = {};

  function setHydrateContext(context) {
    sharedConfig.context = context;
  }

  function nextHydrateContext() {
    return _extends({}, sharedConfig.context, {
      id: "" + sharedConfig.context.id + sharedConfig.context.count++ + ".",
      count: 0
    });
  }

  var equalFn = function equalFn(a, b) {
    return a === b;
  };

  var $PROXY = Symbol("solid-proxy");
  var signalOptions = {
    equals: equalFn
  };
  var runEffects = runQueue;
  var NOTPENDING = {};
  var STALE = 1;
  var PENDING = 2;
  var UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
  };

  var Owner = null;
  var Transition = null;
  var Listener = null;
  var Pending = null;
  var Updates = null;
  var Effects = null;
  var ExecCount = 0;

  function createRenderEffect(fn, value, options) {
    updateComputation(createComputation(fn, value, false, STALE));
  }

  function createMemo(fn, value, options) {
    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
    var c = createComputation(fn, value, true, 0);
    c.pending = NOTPENDING;
    c.observers = null;
    c.observerSlots = null;
    c.comparator = options.equals || undefined;
    updateComputation(c);
    return readSignal.bind(c);
  }

  function batch(fn) {
    if (Pending) return fn();
    var result;
    var q = Pending = [];

    try {
      result = fn();
    } finally {
      Pending = null;
    }

    runUpdates(function () {
      for (var i = 0; i < q.length; i += 1) {
        var data = q[i];

        if (data.pending !== NOTPENDING) {
          var pending = data.pending;
          data.pending = NOTPENDING;
          writeSignal(data, pending);
        }
      }
    }, false);
    return result;
  }

  function untrack(fn) {
    var result,
        listener = Listener;
    Listener = null;
    result = fn();
    Listener = listener;
    return result;
  }

  function readSignal() {
    if (this.state && this.sources) {
      var updates = Updates;
      Updates = null;
      this.state === STALE || Transition   ? updateComputation(this) : lookDownstream(this);
      Updates = updates;
    }

    if (Listener) {
      var sSlot = this.observers ? this.observers.length : 0;

      if (!Listener.sources) {
        Listener.sources = [this];
        Listener.sourceSlots = [sSlot];
      } else {
        Listener.sources.push(this);
        Listener.sourceSlots.push(sSlot);
      }

      if (!this.observers) {
        this.observers = [Listener];
        this.observerSlots = [Listener.sources.length - 1];
      } else {
        this.observers.push(Listener);
        this.observerSlots.push(Listener.sources.length - 1);
      }
    }
    return this.value;
  }

  function writeSignal(node, value, isComp) {
    if (node.comparator) {
      if (node.comparator(node.value, value)) return value;
    }

    if (Pending) {
      if (node.pending === NOTPENDING) Pending.push(node);
      node.pending = value;
      return value;
    }

    var TransitionRunning = false;

    node.value = value;

    if (node.observers && node.observers.length) {
      runUpdates(function () {
        for (var i = 0; i < node.observers.length; i += 1) {
          var o = node.observers[i];
          if (TransitionRunning && Transition.disposed.has(o)) ;
          if (o.pure) Updates.push(o);else Effects.push(o);
          if (o.observers && (TransitionRunning && !o.tState || !TransitionRunning && !o.state)) markUpstream(o);
          if (TransitionRunning) ;else o.state = STALE;
        }

        if (Updates.length > 10e5) {
          Updates = [];
          if (false) ;
          throw new Error();
        }
      }, false);
    }

    return value;
  }

  function updateComputation(node) {
    if (!node.fn) return;
    cleanNode(node);
    var owner = Owner,
        listener = Listener,
        time = ExecCount;
    Listener = Owner = node;
    runComputation(node, node.value, time);

    Listener = listener;
    Owner = owner;
  }

  function runComputation(node, value, time) {
    var nextValue;

    try {
      nextValue = node.fn(value);
    } catch (err) {
      handleError(err);
    }

    if (!node.updatedAt || node.updatedAt <= time) {
      if (node.observers && node.observers.length) {
        writeSignal(node, nextValue);
      } else node.value = nextValue;

      node.updatedAt = time;
    }
  }

  function createComputation(fn, init, pure, state, options) {
    if (state === void 0) {
      state = STALE;
    }

    var c = {
      fn: fn,
      state: state,
      updatedAt: null,
      owned: null,
      sources: null,
      sourceSlots: null,
      cleanups: null,
      value: init,
      owner: Owner,
      context: null,
      pure: pure
    };

    if (Transition && Transition.running) {
      c.state = 0;
      c.tState = state;
    }

    if (Owner === null) ;else if (Owner !== UNOWNED) {
      {
        if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);
      }
    }
    return c;
  }

  function runTop(node) {
    var runningTransition = Transition ;
    if (node.state !== STALE) return node.state = 0;
    if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
    var ancestors = [node];

    while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
      if (node.state || runningTransition ) ancestors.push(node);
    }

    for (var i = ancestors.length - 1; i >= 0; i--) {
      node = ancestors[i];

      if (node.state === STALE || runningTransition ) {
        updateComputation(node);
      } else if (node.state === PENDING || runningTransition ) {
        var updates = Updates;
        Updates = null;
        lookDownstream(node);
        Updates = updates;
      }
    }
  }

  function runUpdates(fn, init) {
    if (Updates) return fn();
    var wait = false;
    if (!init) Updates = [];
    if (Effects) wait = true;else Effects = [];
    ExecCount++;

    try {
      fn();
    } catch (err) {
      handleError(err);
    } finally {
      completeUpdates(wait);
    }
  }

  function completeUpdates(wait) {
    if (Updates) {
      runQueue(Updates);
      Updates = null;
    }

    if (wait) return;

    if (Effects.length) batch(function () {
      runEffects(Effects);
      Effects = null;
    });else {
      Effects = null;
    }
  }

  function runQueue(queue) {
    for (var i = 0; i < queue.length; i++) {
      runTop(queue[i]);
    }
  }

  function lookDownstream(node) {
    node.state = 0;

    for (var i = 0; i < node.sources.length; i += 1) {
      var source = node.sources[i];

      if (source.sources) {
        if (source.state === STALE || Transition  ) runTop(source);else if (source.state === PENDING) lookDownstream(source);
      }
    }
  }

  function markUpstream(node) {
    var runningTransition = Transition ;

    for (var i = 0; i < node.observers.length; i += 1) {
      var o = node.observers[i];

      if (!o.state || runningTransition ) {
        o.state = PENDING;
        if (o.pure) Updates.push(o);else Effects.push(o);
        o.observers && markUpstream(o);
      }
    }
  }

  function cleanNode(node) {
    var i;

    if (node.sources) {
      while (node.sources.length) {
        var source = node.sources.pop(),
            index = node.sourceSlots.pop(),
            obs = source.observers;

        if (obs && obs.length) {
          var n = obs.pop(),
              s = source.observerSlots.pop();

          if (index < obs.length) {
            n.sourceSlots[s] = index;
            obs[index] = n;
            source.observerSlots[index] = s;
          }
        }
      }
    }

    if (node.owned) {
      for (i = 0; i < node.owned.length; i++) {
        cleanNode(node.owned[i]);
      }

      node.owned = null;
    }

    if (node.cleanups) {
      for (i = 0; i < node.cleanups.length; i++) {
        node.cleanups[i]();
      }

      node.cleanups = null;
    }

    node.state = 0;
    node.context = null;
  }

  function handleError(err) {
    throw err;
  }

  function createComponent(Comp, props) {
    if (sharedConfig.context) {
      var c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      var r = untrack(function () {
        return Comp(props);
      });
      setHydrateContext(c);
      return r;
    }

    return untrack(function () {
      return Comp(props);
    });
  }

  function trueFn() {
    return true;
  }

  var propTraps = {
    get: function get(_, property, receiver) {
      if (property === $PROXY) return receiver;
      return _.get(property);
    },
    has: function has(_, property) {
      return _.has(property);
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_, property) {
      return {
        configurable: true,
        enumerable: true,
        get: function get() {
          return _.get(property);
        },
        set: trueFn,
        deleteProperty: trueFn
      };
    },
    ownKeys: function ownKeys(_) {
      return _.keys();
    }
  };

  function mergeProps() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }

    return new Proxy({
      get: function get(property) {
        for (var i = sources.length - 1; i >= 0; i--) {
          var v = sources[i][property];
          if (v !== undefined) return v;
        }
      },
      has: function has(property) {
        for (var i = sources.length - 1; i >= 0; i--) {
          if (property in sources[i]) return true;
        }

        return false;
      },
      keys: function keys() {
        var keys = [];

        for (var i = 0; i < sources.length; i++) {
          keys.push.apply(keys, Object.keys(sources[i]));
        }

        return [].concat(new Set(keys));
      }
    }, propTraps);
  }

  function Show(props) {
    var strictEqual = false;
    var condition = createMemo(function () {
      return props.when;
    }, undefined, {
      equals: function equals(a, b) {
        return strictEqual ? a === b : !a === !b;
      }
    });
    return createMemo(function () {
      var c = condition();

      if (c) {
        var child = props.children;
        return (strictEqual = typeof child === "function" && child.length > 0) ? untrack(function () {
          return child(c);
        }) : child;
      }

      return props.fallback;
    });
  }

  function reconcileArrays(parentNode, a, b) {
    var bLength = b.length,
        aEnd = a.length,
        bEnd = bLength,
        aStart = 0,
        bStart = 0,
        after = a[aEnd - 1].nextSibling,
        map = null;

    while (aStart < aEnd || bStart < bEnd) {
      if (a[aStart] === b[bStart]) {
        aStart++;
        bStart++;
        continue;
      }

      while (a[aEnd - 1] === b[bEnd - 1]) {
        aEnd--;
        bEnd--;
      }

      if (aEnd === aStart) {
        var node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;

        while (bStart < bEnd) {
          parentNode.insertBefore(b[bStart++], node);
        }
      } else if (bEnd === bStart) {
        while (aStart < aEnd) {
          if (!map || !map.has(a[aStart])) parentNode.removeChild(a[aStart]);
          aStart++;
        }
      } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
        var _node = a[--aEnd].nextSibling;
        parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
        parentNode.insertBefore(b[--bEnd], _node);
        a[aEnd] = b[bEnd];
      } else {
        if (!map) {
          map = new Map();
          var i = bStart;

          while (i < bEnd) {
            map.set(b[i], i++);
          }
        }

        var index = map.get(a[aStart]);

        if (index != null) {
          if (bStart < index && index < bEnd) {
            var _i = aStart,
                sequence = 1,
                t = void 0;

            while (++_i < aEnd && _i < bEnd) {
              if ((t = map.get(a[_i])) == null || t !== index + sequence) break;
              sequence++;
            }

            if (sequence > index - bStart) {
              var _node2 = a[aStart];

              while (bStart < index) {
                parentNode.insertBefore(b[bStart++], _node2);
              }
            } else parentNode.replaceChild(b[bStart++], a[aStart++]);
          } else aStart++;
        } else parentNode.removeChild(a[aStart++]);
      }
    }
  }

  function template(html, check, isSVG) {
    var t = document.createElement("template");
    t.innerHTML = html;
    var node = t.content.firstChild;
    if (isSVG) node = node.firstChild;
    return node;
  }

  function setAttribute(node, name, value) {
    if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);
  }

  function classList(node, value, prev) {
    if (prev === void 0) {
      prev = {};
    }

    var classKeys = Object.keys(value),
        prevKeys = Object.keys(prev);
    var i, len;

    for (i = 0, len = prevKeys.length; i < len; i++) {
      var key = prevKeys[i];
      if (!key || key === "undefined" || key in value) continue;
      toggleClassKey(node, key, false);
      delete prev[key];
    }

    for (i = 0, len = classKeys.length; i < len; i++) {
      var _key = classKeys[i],
          classValue = !!value[_key];
      if (!_key || _key === "undefined" || prev[_key] === classValue) continue;
      toggleClassKey(node, _key, classValue);
      prev[_key] = classValue;
    }

    return prev;
  }

  function style$2(node, value, prev) {
    if (prev === void 0) {
      prev = {};
    }

    var nodeStyle = node.style;
    if (value == null || typeof value === "string") return nodeStyle.cssText = value;
    typeof prev === "string" && (prev = {});
    var v, s;

    for (s in prev) {
      value[s] == null && nodeStyle.removeProperty(s);
      delete prev[s];
    }

    for (s in value) {
      v = value[s];

      if (v !== prev[s]) {
        nodeStyle.setProperty(s, v);
        prev[s] = v;
      }
    }

    return prev;
  }

  function insert(parent, accessor, marker, initial) {
    if (marker !== undefined && !initial) initial = [];
    if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
    createRenderEffect(function (current) {
      return insertExpression(parent, accessor(), current, marker);
    }, initial);
  }

  function toggleClassKey(node, key, value) {
    var classNames = key.trim().split(/\s+/);

    for (var i = 0, nameLen = classNames.length; i < nameLen; i++) {
      node.classList.toggle(classNames[i], value);
    }
  }

  function insertExpression(parent, value, current, marker, unwrapArray) {
    while (typeof current === "function") {
      current = current();
    }

    if (value === current) return current;
    var t = typeof value,
        multi = marker !== undefined;
    parent = multi && current[0] && current[0].parentNode || parent;

    if (t === "string" || t === "number") {
      if (t === "number") value = value.toString();

      if (multi) {
        var node = current[0];

        if (node && node.nodeType === 3) {
          node.data = value;
        } else node = document.createTextNode(value);

        current = cleanChildren(parent, current, marker, node);
      } else {
        if (current !== "" && typeof current === "string") {
          current = parent.firstChild.data = value;
        } else current = parent.textContent = value;
      }
    } else if (value == null || t === "boolean") {
      if (sharedConfig.context) return current;
      current = cleanChildren(parent, current, marker);
    } else if (t === "function") {
      createRenderEffect(function () {
        var v = value();

        while (typeof v === "function") {
          v = v();
        }

        current = insertExpression(parent, v, current, marker);
      });
      return function () {
        return current;
      };
    } else if (Array.isArray(value)) {
      var array = [];

      if (normalizeIncomingArray(array, value, unwrapArray)) {
        createRenderEffect(function () {
          return current = insertExpression(parent, array, current, marker, true);
        });
        return function () {
          return current;
        };
      }

      if (sharedConfig.context && current && current.length) return current;

      if (array.length === 0) {
        current = cleanChildren(parent, current, marker);
        if (multi) return current;
      } else {
        if (Array.isArray(current)) {
          if (current.length === 0) {
            appendNodes(parent, array, marker);
          } else reconcileArrays(parent, current, array);
        } else if (current == null || current === "") {
          appendNodes(parent, array);
        } else {
          reconcileArrays(parent, multi && current || [parent.firstChild], array);
        }
      }

      current = array;
    } else if (value instanceof Node) {
      if (Array.isArray(current)) {
        if (multi) return current = cleanChildren(parent, current, marker, value);
        cleanChildren(parent, current, null, value);
      } else if (current == null || current === "" || !parent.firstChild) {
        parent.appendChild(value);
      } else parent.replaceChild(value, parent.firstChild);

      current = value;
    } else ;

    return current;
  }

  function normalizeIncomingArray(normalized, array, unwrap) {
    var dynamic = false;

    for (var i = 0, len = array.length; i < len; i++) {
      var item = array[i],
          t = void 0;

      if (item instanceof Node) {
        normalized.push(item);
      } else if (item == null || item === true || item === false) ;else if (Array.isArray(item)) {
        dynamic = normalizeIncomingArray(normalized, item) || dynamic;
      } else if ((t = typeof item) === "string") {
        normalized.push(document.createTextNode(item));
      } else if (t === "function") {
        if (unwrap) {
          while (typeof item === "function") {
            item = item();
          }

          dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
        } else {
          normalized.push(item);
          dynamic = true;
        }
      } else normalized.push(document.createTextNode(item.toString()));
    }

    return dynamic;
  }

  function appendNodes(parent, array, marker) {
    for (var i = 0, len = array.length; i < len; i++) {
      parent.insertBefore(array[i], marker);
    }
  }

  function cleanChildren(parent, current, marker, replacement) {
    if (marker === undefined) return parent.textContent = "";
    var node = replacement || document.createTextNode("");

    if (current.length) {
      var inserted = false;

      for (var i = current.length - 1; i >= 0; i--) {
        var el = current[i];

        if (node !== el) {
          var isParent = el.parentNode === parent;
          if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && parent.removeChild(el);
        } else inserted = true;
      }
    } else parent.insertBefore(node, marker);

    return [node];
  }

  var parseNumber = parseFloat;
  function joinCss(obj, separator) {
    if (separator === void 0) {
      separator = ';';
    }

    var texts;

    if (Array.isArray(obj)) {
      texts = obj.filter(function (text) {
        return text;
      });
    } else {
      texts = [];

      for (var prop in obj) {
        if (obj[prop]) {
          texts.push(prop + ":" + obj[prop]);
        }
      }
    }

    return texts.join(separator);
  }
  function getStyles(size, pull, fw) {
    var float;
    var width;
    var height = '1em';
    var lineHeight;
    var fontSize;
    var textAlign;
    var verticalAlign = '-.125em';
    var overflow = 'visible';

    if (fw) {
      textAlign = 'center';
      width = '1.25em';
    }

    if (pull) {
      float = pull;
    }

    if (size) {
      if (size === 'lg') {
        fontSize = '1.33333em';
        lineHeight = '.75em';
        verticalAlign = '-.225em';
      } else if (size === 'xs') {
        fontSize = '.75em';
      } else if (size === 'sm') {
        fontSize = '.875em';
      } else {
        fontSize = size.replace('x', 'em');
      }
    }

    return {
      float: float,
      width: width,
      height: height,
      'line-height': lineHeight,
      'font-size': fontSize,
      'text-align': textAlign,
      'vertical-align': verticalAlign,
      'transform-origin': 'center',
      overflow: overflow
    };
  }
  function getTransform(scale, translateX, translateY, rotate, flip, translateTimes, translateUnit, rotateUnit) {
    if (translateTimes === void 0) {
      translateTimes = 1;
    }

    if (translateUnit === void 0) {
      translateUnit = '';
    }

    if (rotateUnit === void 0) {
      rotateUnit = '';
    }

    var flipX = 1;
    var flipY = 1;

    if (flip) {
      if (flip === 'horizontal') {
        flipX = -1;
      } else if (flip === 'vertical') {
        flipY = -1;
      } else {
        flipX = flipY = -1;
      }
    }

    return joinCss(["translate(" + parseNumber(translateX) * translateTimes + translateUnit + "," + parseNumber(translateY) * translateTimes + translateUnit + ")", "scale(" + flipX * parseNumber(scale) + "," + flipY * parseNumber(scale) + ")", rotate && "rotate(" + rotate + rotateUnit + ")"], ' ');
  }

  function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') {
      return;
    }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$1 = "._1yhTRa{animation:_1yhTRa 2s linear 0s infinite}._2dBo7A{animation:_1yhTRa 1s steps(8) infinite}@keyframes _1yhTRa{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}";
  var style$1 = {"spin":"_1yhTRa","pulse":"_2dBo7A"};
  styleInject(css_248z$1);

  const _tmpl$$2 = template(`<svg><path></path></svg>`, 4, true),
        _tmpl$2 = template(`<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><g><g></g></g></svg>`);
  function Fa(props) {
    props = mergeProps({
      scale: 1,
      translateX: 0,
      translateY: 0,
      primaryOpacity: 1,
      secondaryOpacity: 0.4
    }, props);
    var i = createMemo(function () {
      var _props$icon;

      return ((_props$icon = props.icon) == null ? void 0 : _props$icon.icon) || [0, 0, '', [], ''];
    });
    var s = createMemo(function () {
      return getStyles(props.size, props.pull, props.fw);
    });
    var transform = createMemo(function () {
      return getTransform(props.scale, props.translateX, props.translateY, props.rotate, props.flip, 512);
    });
    return function () {
      var _el$ = _tmpl$2.cloneNode(true),
          _el$2 = _el$.firstChild,
          _el$3 = _el$2.firstChild;

      insert(_el$3, createComponent(Show, {
        get when() {
          return typeof i()[4] === 'string';
        },

        get fallback() {
          return [function () {
            var _el$5 = _tmpl$$2.cloneNode(true);

            createRenderEffect(function (_p$) {
              var _v$11 = i()[4][0],
                  _v$12 = props.secondaryColor || props.color || 'currentColor',
                  _v$13 = props.swapOpacity != false ? props.primaryOpacity : props.secondaryOpacity,
                  _v$14 = "translate(" + i()[0] / -2 + " " + i()[1] / -2 + ")";

              _v$11 !== _p$._v$11 && setAttribute(_el$5, "d", _p$._v$11 = _v$11);
              _v$12 !== _p$._v$12 && setAttribute(_el$5, "fill", _p$._v$12 = _v$12);
              _v$13 !== _p$._v$13 && setAttribute(_el$5, "fill-opacity", _p$._v$13 = _v$13);
              _v$14 !== _p$._v$14 && setAttribute(_el$5, "transform", _p$._v$14 = _v$14);
              return _p$;
            }, {
              _v$11: undefined,
              _v$12: undefined,
              _v$13: undefined,
              _v$14: undefined
            });

            return _el$5;
          }(), function () {
            var _el$6 = _tmpl$$2.cloneNode(true);

            createRenderEffect(function (_p$) {
              var _v$15 = i()[4][1],
                  _v$16 = props.primaryColor || props.color || 'currentColor',
                  _v$17 = props.swapOpacity != false ? props.secondaryOpacity : props.primaryOpacity,
                  _v$18 = "translate(" + i()[0] / -2 + " " + i()[1] / -2 + ")";

              _v$15 !== _p$._v$15 && setAttribute(_el$6, "d", _p$._v$15 = _v$15);
              _v$16 !== _p$._v$16 && setAttribute(_el$6, "fill", _p$._v$16 = _v$16);
              _v$17 !== _p$._v$17 && setAttribute(_el$6, "fill-opacity", _p$._v$17 = _v$17);
              _v$18 !== _p$._v$18 && setAttribute(_el$6, "transform", _p$._v$18 = _v$18);
              return _p$;
            }, {
              _v$15: undefined,
              _v$16: undefined,
              _v$17: undefined,
              _v$18: undefined
            });

            return _el$6;
          }()];
        },

        get children() {
          var _el$4 = _tmpl$$2.cloneNode(true);

          createRenderEffect(function (_p$) {
            var _v$ = i()[4],
                _v$2 = props.color || props.primaryColor || 'currentColor',
                _v$3 = "translate(" + i()[0] / -2 + " " + i()[1] / -2 + ")";

            _v$ !== _p$._v$ && setAttribute(_el$4, "d", _p$._v$ = _v$);
            _v$2 !== _p$._v$2 && setAttribute(_el$4, "fill", _p$._v$2 = _v$2);
            _v$3 !== _p$._v$3 && setAttribute(_el$4, "transform", _p$._v$3 = _v$3);
            return _p$;
          }, {
            _v$: undefined,
            _v$2: undefined,
            _v$3: undefined
          });

          return _el$4;
        }

      }));

      createRenderEffect(function (_p$) {
        var _extends2;

        var _v$4 = _extends((_extends2 = {
          'solid-fa': true
        }, _extends2[style$1.spin] = props.spin, _extends2[style$1.pulse] = props.pulse, _extends2), props.classList),
            _v$5 = props.class,
            _v$6 = s(),
            _v$7 = "0 0 " + i()[0] + " " + i()[1],
            _v$8 = "translate(" + i()[0] / 2 + " " + i()[1] / 2 + ")",
            _v$9 = i()[0] / 4 + " 0",
            _v$10 = transform();

        _p$._v$4 = classList(_el$, _v$4, _p$._v$4);
        _v$5 !== _p$._v$5 && setAttribute(_el$, "class", _p$._v$5 = _v$5);
        _p$._v$6 = style$2(_el$, _v$6, _p$._v$6);
        _v$7 !== _p$._v$7 && setAttribute(_el$, "viewBox", _p$._v$7 = _v$7);
        _v$8 !== _p$._v$8 && setAttribute(_el$2, "transform", _p$._v$8 = _v$8);
        _v$9 !== _p$._v$9 && setAttribute(_el$2, "transform-origin", _p$._v$9 = _v$9);
        _v$10 !== _p$._v$10 && setAttribute(_el$3, "transform", _p$._v$10 = _v$10);
        return _p$;
      }, {
        _v$4: undefined,
        _v$5: undefined,
        _v$6: undefined,
        _v$7: undefined,
        _v$8: undefined,
        _v$9: undefined,
        _v$10: undefined
      });

      return _el$;
    }();
  }

  var css_248z = "._2RIh6I{display:inline-block;position:relative}._2RIh6I .solid-fa{position:absolute;bottom:0;left:0;right:0;top:0;margin:auto;text-align:center}._2RIh6I .solid-fa-layers-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}._2RIh6I .solid-fa-layers-text span{display:inline-block}";
  var style = {"layers":"_2RIh6I"};
  styleInject(css_248z);

  const _tmpl$$1 = template(`<span></span>`);
  function FaLayers(props) {
    var s = createMemo(function () {
      return getStyles(props.size, props.pull, true);
    });
    return function () {
      var _el$ = _tmpl$$1.cloneNode(true);

      insert(_el$, function () {
        return props.children;
      });

      createRenderEffect(function (_p$) {
        var _v$3;

        var _v$ = (_v$3 = {}, _v$3[style.layers] = true, _v$3),
            _v$2 = s();

        _p$._v$ = classList(_el$, _v$, _p$._v$);
        _p$._v$2 = style$2(_el$, _v$2, _p$._v$2);
        return _p$;
      }, {
        _v$: undefined,
        _v$2: undefined
      });

      return _el$;
    }();
  }

  const _tmpl$ = template(`<span class="solid-fa-layers-text"><span></span></span>`);
  function FaLayersText(props) {
    props = mergeProps({
      scale: 1,
      translateX: 0,
      translateY: 0
    }, props);
    var s = createMemo(function () {
      return _extends({}, getStyles(props.size), {
        color: props.color,
        display: 'inline-block',
        height: 'auto',
        transform: getTransform(props.scale, props.translateX, props.translateY, props.rotate, props.flip, undefined, 'em', 'deg')
      });
    });
    return function () {
      var _el$ = _tmpl$.cloneNode(true),
          _el$2 = _el$.firstChild;

      insert(_el$2, function () {
        return props.children;
      });

      createRenderEffect(function (_$p) {
        return style$2(_el$2, s(), _$p);
      });

      return _el$;
    }();
  }

  exports.Fa = Fa;
  exports.FaLayers = FaLayers;
  exports.FaLayersText = FaLayersText;
  exports.default = Fa;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}));
